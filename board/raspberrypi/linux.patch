--- a/sound/arm/bcm2835-vchiq.c
+++ b/sound/arm/bcm2835-vchiq.c
@@ -669,7 +669,7 @@ static int bcm2835_audio_stop_worker(bcm2835_alsa_stream_t * alsa_stream)
 	VC_AUDIO_MSG_T m;
 	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
 	int32_t success;
-	int ret;
+	int ret = 0;
 	LOG_DBG(" .. IN\n");
 
 	if(mutex_lock_interruptible(&instance->vchi_mutex))
@@ -695,7 +695,145 @@ static int bcm2835_audio_stop_worker(bcm2835_alsa_stream_t * alsa_stream)
 		goto unlock;
 	}
 
-	ret = 0;
+	/* HACK !!!!
+	 * When not draining we expected that all samples will be dropped. It seems
+	 * that the m.u.stop.draining argument should be used to indicate VC about
+	 * this but this doesn't seem to be the case and only a few samples are
+	 * being flushed. This behaviour makes snd_pcm_drop unreliable and it
+	 * affects applications that use it like for example
+	 * GStreamer alsasink element.
+	 * The following workaround addresses the issue by flushing VC with
+	 * a close/open/config sequence.
+	 * A proper fix should be implemented in the VC side to avoid the following
+	 * code.
+	 */
+	if (!alsa_stream->draining) {
+		/* Close */
+		m.type = VC_AUDIO_MSG_TYPE_CLOSE;
+
+		/* Create the message available completion */
+		init_completion(&instance->msg_avail_comp);
+
+		/* Send the message to the videocore */
+		success = vchi_msg_queue(instance->vchi_handle[0],
+					&m, sizeof m,
+					VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
+
+		if (success != 0) {
+			LOG_ERR("%s: failed on vchi_msg_queue (status=%d)",
+			  __func__, success);
+			ret = -1;
+			goto unlock;
+		}
+
+		ret = wait_for_completion_interruptible(&instance->msg_avail_comp);
+		if (ret) {
+			LOG_ERR("%s: failed on waiting for event (status=%d)",
+			  __func__, success);
+			goto unlock;
+		}
+
+		if (instance->result != 0) {
+			LOG_ERR("%s: failed result (status=%d)",
+			  __func__, instance->result);
+
+			ret = -1;
+			goto unlock;
+		}
+
+		/* Open */
+		m.type = VC_AUDIO_MSG_TYPE_OPEN;
+
+		/* Send the message to the videocore */
+		success = vchi_msg_queue(instance->vchi_handle[0],
+				   &m, sizeof m,
+				   VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
+
+		if (success != 0) {
+			LOG_ERR("%s: failed on vchi_msg_queue (status=%d)\n",
+			  __func__, success);
+
+			ret = -1;
+			goto unlock;
+		}
+
+		/* Configure volume */
+		instance->result = -1;
+
+		m.type = VC_AUDIO_MSG_TYPE_CONTROL;
+		m.u.control.dest = alsa_stream->chip->dest;
+		m.u.control.volume = alsa_stream->chip->volume;
+
+		/* Create the message available completion */
+		init_completion(&instance->msg_avail_comp);
+
+		/* Send the message to the videocore */
+		success = vchi_msg_queue(instance->vchi_handle[0],
+					&m, sizeof m,
+					VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
+
+		if (success != 0) {
+			LOG_ERR("%s: failed on vchi_msg_queue (status=%d)\n",
+			  __func__, success);
+
+			ret = -1;
+			goto unlock;
+		}
+
+		/* We are expecting a reply from the videocore */
+		ret = wait_for_completion_interruptible(&instance->msg_avail_comp);
+		if (ret) {
+			LOG_ERR("%s: failed on waiting for event (status=%d)\n",
+			  __func__, success);
+			goto unlock;
+		}
+
+		if (instance->result != 0) {
+			LOG_ERR("%s: result=%d\n", __func__, instance->result);
+
+			ret = -1;
+			goto unlock;
+		}
+
+		/* Configure format */
+		instance->result = -1;
+
+		m.type = VC_AUDIO_MSG_TYPE_CONFIG;
+		m.u.config.channels = alsa_stream->substream->runtime->channels;
+		m.u.config.samplerate = alsa_stream->substream->runtime->rate;
+		m.u.config.bps = alsa_stream->substream->runtime->sample_bits;
+
+		/* Create the message available completion */
+		init_completion(&instance->msg_avail_comp);
+
+		/* Send the message to the videocore */
+		success = vchi_msg_queue(instance->vchi_handle[0],
+				   &m, sizeof m,
+				   VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
+
+		if (success != 0) {
+			LOG_ERR("%s: failed on vchi_msg_queue (status=%d)\n",
+			  __func__, success);
+
+			ret = -1;
+			goto unlock;
+		}
+
+		/* We are expecting a reply from the videocore */
+		ret = wait_for_completion_interruptible(&instance->msg_avail_comp);
+		if (ret) {
+			LOG_ERR("%s: failed on waiting for event (status=%d)\n",
+			  __func__, success);
+			goto unlock;
+		}
+
+		if (instance->result != 0) {
+			LOG_ERR("%s: result=%d", __func__, instance->result);
+
+			ret = -1;
+			goto unlock;
+		}
+	}
 
 unlock:
 	vchi_service_release(instance->vchi_handle[0]);
--- a/tools/lib/lk/Makefile
+++ b/tools/lib/lk/Makefile
@@ -16,6 +16,8 @@ ALL_CFLAGS = $(CFLAGS) $(BASIC_CFLAGS) -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS
 ALL_LDFLAGS = $(LDFLAGS)
 
 RM = rm -f
+AR = $(CROSS_COMPILE)ar
+CC = $(CROSS_COMPILE)cc
 
 $(LIBFILE): $(LIB_OBJS)
 	$(QUIET_AR)$(RM) $@ && $(AR) rcs $(OUTPUT)$@ $(LIB_OBJS)
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -60,7 +60,7 @@
 # macro, but instead defines a whole series of macros which makes
 # testing for a specific architecture or later rather impossible.
 arch-$(CONFIG_CPU_32v7)		:=-D__LINUX_ARM_ARCH__=7 $(call cc-option,-march=armv7-a,-march=armv5t -Wa$(comma)-march=armv7-a)
-arch-$(CONFIG_CPU_32v6)		:=-D__LINUX_ARM_ARCH__=6 $(call cc-option,-march=armv6,-march=armv5t -Wa$(comma)-march=armv6)
+arch-$(CONFIG_CPU_32v6)		:=-D__LINUX_ARM_ARCH__=6 -Ofast -mcpu=arm1176jzf-s -mtune=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp -fomit-frame-pointer -fexcess-precision=fast
 # Only override the compiler option if ARMv6. The ARMv6K extensions are
 # always available in ARMv7
 ifeq ($(CONFIG_CPU_32v6),y)
@@ -116,9 +116,8 @@
 endif
 
 # Need -Uarm for gcc < 3.x
-KBUILD_CFLAGS	+=$(CFLAGS_ABI) $(CFLAGS_ISA) $(arch-y) $(tune-y) $(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,)) -msoft-float -Uarm
-KBUILD_AFLAGS	+=$(CFLAGS_ABI) $(AFLAGS_ISA) $(arch-y) $(tune-y) -include asm/unified.h -msoft-float
-
+KBUILD_CFLAGS	+=$(CFLAGS_ABI) $(CFLAGS_THUMB2) $(arch-y) $(tune-y) $(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,)) -Uarm
+KBUILD_AFLAGS	+=$(CFLAGS_ABI) $(AFLAGS_THUMB2) $(arch-y) $(tune-y) -include asm/unified.h
 CHECKFLAGS	+= -D__arm__
 
 #Default value
