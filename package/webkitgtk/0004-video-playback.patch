diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
index a13a687..4517614 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
@@ -114,6 +114,12 @@ static gboolean mediaPlayerPrivateAudioChangeTimeoutCallback(MediaPlayerPrivateG
     return FALSE;
 }
 
+static GstBusSyncReply mediaPlayerPrivateSyncMessageCallback (GstBus * bus, GstMessage * message, MediaPlayerPrivateGStreamer* player)
+{
+  // TODO
+  return GST_BUS_PASS;
+}
+
 static void setAudioStreamPropertiesCallback(GstChildProxy*, GObject* object, gchar*,
     MediaPlayerPrivateGStreamer* player)
 {
@@ -213,7 +219,7 @@ bool initializeGStreamerAndRegisterWebKitElements()
     GRefPtr<GstElementFactory> srcFactory = gst_element_factory_find("webkitwebsrc");
     if (!srcFactory) {
         GST_DEBUG_CATEGORY_INIT(webkit_media_player_debug, "webkitmediaplayer", 0, "WebKit media player");
-        gst_element_register(0, "webkitwebsrc", GST_RANK_PRIMARY + 100, WEBKIT_TYPE_WEB_SRC);
+        // gst_element_register(0, "webkitwebsrc", GST_RANK_PRIMARY + 100, WEBKIT_TYPE_WEB_SRC);
     }
 
 #if ENABLE(MEDIA_SOURCE)
@@ -239,7 +245,6 @@ MediaPlayerPrivateGStreamer::MediaPlayerPrivateGStreamer(MediaPlayer* player)
     , m_seekTime(0)
     , m_changingRate(false)
     , m_endTime(numeric_limits<float>::infinity())
-    , m_isEndReached(false)
     , m_isStreaming(false)
     , m_mediaLocations(0)
     , m_mediaLocationCurrentIndex(0)
@@ -1866,10 +1871,11 @@ void MediaPlayerPrivateGStreamer::createGSTPlayBin()
     setStreamVolumeElement(GST_STREAM_VOLUME(m_playBin.get()));
 
     GRefPtr<GstBus> bus = adoptGRef(gst_pipeline_get_bus(GST_PIPELINE(m_playBin.get())));
+    gst_bus_set_sync_handler(bus.get(), (GstBusSyncHandler) mediaPlayerPrivateSyncMessageCallback, this, 0);
     gst_bus_add_signal_watch(bus.get());
     g_signal_connect(bus.get(), "message", G_CALLBACK(mediaPlayerPrivateMessageCallback), this);
 
-    g_object_set(m_playBin.get(), "mute", m_player->muted(), NULL);
+    g_object_set(m_playBin.get(), "mute", m_player->muted(), "flags", GST_PLAY_FLAG_NATIVE_VIDEO | GST_PLAY_FLAG_SOFT_VOLUME | GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_VIDEO, NULL);
 
     g_signal_connect(m_playBin.get(), "notify::source", G_CALLBACK(mediaPlayerPrivateSourceChangedCallback), this);
     g_signal_connect(m_playBin.get(), "video-changed", G_CALLBACK(mediaPlayerPrivateVideoChangedCallback), this);
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
index fa18910..01ff350 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
@@ -164,7 +164,6 @@ private:
     float m_seekTime;
     bool m_changingRate;
     float m_endTime;
-    bool m_isEndReached;
     mutable bool m_isStreaming;
     GstStructure* m_mediaLocations;
     int m_mediaLocationCurrentIndex;
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.cpp
index 4d12e3a..90a3c37 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.cpp
@@ -43,10 +43,36 @@
 
 #include <gst/audio/streamvolume.h>
 
-#if GST_CHECK_VERSION(1, 1, 0) && USE(ACCELERATED_COMPOSITING) && USE(TEXTURE_MAPPER_GL)
+#if USE(ACCELERATED_COMPOSITING) && USE(TEXTURE_MAPPER_GL)
 #include "TextureMapperGL.h"
 #endif
 
+#if USE(ACCELERATED_COMPOSITING) && USE(TEXTURE_MAPPER_GL) && PLATFORM(QT)
+#define GL_GLEXT_PROTOTYPES
+#include "OpenGLShims.h"
+#endif
+
+#define WL_EGL_PLATFORM
+
+#if USE(OPENGL_ES_2)
+#define GL_GLEXT_PROTOTYPES
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+#if GST_CHECK_VERSION(1, 3, 0)
+#include <gst/gl/egl/gsteglimagememory.h>
+#endif
+#endif
+
+#define EGL_EGLEXT_PROTOTYPES
+#include <EGL/egl.h>
+
+struct _EGLDetails {
+    EGLDisplay display;
+    EGLContext context;
+    EGLSurface draw;
+    EGLSurface read;
+};
+
 GST_DEBUG_CATEGORY(webkit_media_player_debug);
 #define GST_CAT_DEFAULT webkit_media_player_debug
 
@@ -97,11 +123,17 @@ static void mediaPlayerPrivateRepaintCallback(WebKitVideoSink*, GstBuffer *buffe
     playerPrivate->triggerRepaint(buffer);
 }
 
+static void mediaPlayerPrivateDrainCallback(WebKitVideoSink*, MediaPlayerPrivateGStreamerBase* playerPrivate)
+{
+    playerPrivate->triggerDrain();
+}
+
 MediaPlayerPrivateGStreamerBase::MediaPlayerPrivateGStreamerBase(MediaPlayer* player)
     : m_player(player)
     , m_fpsSink(0)
     , m_readyState(MediaPlayer::HaveNothing)
     , m_networkState(MediaPlayer::Empty)
+    , m_isEndReached(false)
     , m_buffer(0)
     , m_volumeTimerHandler(0)
     , m_muteTimerHandler(0)
@@ -119,7 +151,13 @@ MediaPlayerPrivateGStreamerBase::MediaPlayerPrivateGStreamerBase(MediaPlayer* pl
 
 MediaPlayerPrivateGStreamerBase::~MediaPlayerPrivateGStreamerBase()
 {
-    g_signal_handler_disconnect(m_webkitVideoSink.get(), m_repaintHandler);
+    if (m_repaintHandler)
+        g_signal_handler_disconnect(m_webkitVideoSink.get(), m_repaintHandler);
+    m_repaintHandler = 0;
+
+    if (m_drainHandler)
+        g_signal_handler_disconnect(m_webkitVideoSink.get(), m_drainHandler);
+    m_drainHandler = 0;
 
 #if GLIB_CHECK_VERSION(2, 31, 0)
     g_mutex_clear(m_bufferMutex);
@@ -136,9 +174,11 @@ MediaPlayerPrivateGStreamerBase::~MediaPlayerPrivateGStreamerBase()
 
     if (m_muteTimerHandler)
         g_source_remove(m_muteTimerHandler);
+    m_muteTimerHandler = 0;
 
     if (m_volumeTimerHandler)
         g_source_remove(m_volumeTimerHandler);
+    m_volumeTimerHandler = 0;
 
     if (m_volumeSignalHandler) {
         g_signal_handler_disconnect(m_volumeElement.get(), m_volumeSignalHandler);
@@ -326,6 +366,56 @@ PassRefPtr<BitmapTexture> MediaPlayerPrivateGStreamerBase::updateTexture(Texture
 
     RefPtr<BitmapTexture> texture = textureMapper->acquireTextureFromPool(size, GST_VIDEO_FORMAT_INFO_HAS_ALPHA(formatInfo) ? BitmapTexture::SupportsAlpha : BitmapTexture::NoFlag);
 
+#if USE(OPENGL_ES_2) && GST_CHECK_VERSION(1, 1, 2)
+    GstMemory *mem;
+    if (gst_buffer_n_memory (m_buffer) >= 1) {
+        if ((mem = gst_buffer_peek_memory (m_buffer, 0)) && gst_is_egl_image_memory (mem)) {
+            guint n, i;
+
+            n = gst_buffer_n_memory (m_buffer);
+
+            LOG_MEDIA_MESSAGE("MediaPlayerPrivateGStreamerBase::updateTexture: buffer contains %d memories", n);
+
+            n = 1; // FIXME
+            const BitmapTextureGL* textureGL = static_cast<const BitmapTextureGL*>(texture.get()); // FIXME
+
+            for (i = 0; i < n; i++) {
+                mem = gst_buffer_peek_memory (m_buffer, i);
+
+                g_assert (gst_is_egl_image_memory (mem));
+
+                if (i == 0)
+                    glActiveTexture (GL_TEXTURE0);
+                else if (i == 1)
+                    glActiveTexture (GL_TEXTURE1);
+                else if (i == 2)
+                    glActiveTexture (GL_TEXTURE2);
+
+                glBindTexture (GL_TEXTURE_2D, textureGL->id()); // FIXME
+                glEGLImageTargetTexture2DOES (GL_TEXTURE_2D,
+                    gst_egl_image_memory_get_image (mem));
+
+                GLuint error = glGetError ();
+                if (error != GL_NO_ERROR)
+                    LOG_ERROR("MediaPlayerPrivateGStreamerBase::updateTexture: glEGLImageTargetTexture2DOES returned 0x%04x\n", error);
+
+                m_orientation = gst_egl_image_memory_get_orientation (mem);
+                if (m_orientation != GST_VIDEO_GL_TEXTURE_ORIENTATION_X_NORMAL_Y_NORMAL
+                    && m_orientation != GST_VIDEO_GL_TEXTURE_ORIENTATION_X_NORMAL_Y_FLIP) {
+                    LOG_ERROR("MediaPlayerPrivateGStreamerBase::updateTexture: invalid GstEGLImage orientation");
+                }
+                else
+                  LOG_MEDIA_MESSAGE("MediaPlayerPrivateGStreamerBase::updateTexture: texture orientation is Y FLIP?: %d",
+                      (m_orientation == GST_VIDEO_GL_TEXTURE_ORIENTATION_X_NORMAL_Y_FLIP));
+            }
+
+            g_mutex_unlock(m_bufferMutex);
+            return texture;
+        }
+    }
+
+    return 0;
+#else
 #if GST_CHECK_VERSION(1, 1, 0)
     GstVideoGLTextureUploadMeta* meta;
     if ((meta = gst_buffer_get_video_gl_texture_upload_meta(m_buffer))) {
@@ -347,6 +437,8 @@ PassRefPtr<BitmapTexture> MediaPlayerPrivateGStreamerBase::updateTexture(Texture
 
     gst_buffer_unmap(m_buffer, &srcInfo);
     return texture;
+#endif
+    return 0;
 }
 #endif
 
@@ -369,6 +461,17 @@ void MediaPlayerPrivateGStreamerBase::triggerRepaint(GstBuffer* buffer)
     m_player->repaint();
 }
 
+void MediaPlayerPrivateGStreamerBase::triggerDrain()
+{
+    m_videoSize.setWidth(0);
+    m_videoSize.setHeight(0);
+    g_mutex_lock(m_bufferMutex);
+    if (m_buffer)
+        gst_buffer_unref(m_buffer);
+    m_buffer = 0;
+    g_mutex_unlock(m_bufferMutex);
+}
+
 void MediaPlayerPrivateGStreamerBase::setSize(const IntSize& size)
 {
     m_size = size;
@@ -404,7 +507,7 @@ void MediaPlayerPrivateGStreamerBase::paint(GraphicsContext* context, const IntR
 }
 
 #if USE(ACCELERATED_COMPOSITING) && USE(TEXTURE_MAPPER_GL) && !USE(COORDINATED_GRAPHICS)
-void MediaPlayerPrivateGStreamerBase::paintToTextureMapper(TextureMapper* textureMapper, const FloatRect& targetRect, const TransformationMatrix& matrix, float opacity)
+void MediaPlayerPrivateGStreamerBase::paintToTextureMapper(TextureMapper* textureMapper, const FloatRect& targetRect, const TransformationMatrix& modelViewMatrix, float opacity)
 {
     if (textureMapper->accelerationMode() != TextureMapper::OpenGLMode)
         return;
@@ -413,8 +516,21 @@ void MediaPlayerPrivateGStreamerBase::paintToTextureMapper(TextureMapper* textur
         return;
 
     RefPtr<BitmapTexture> texture = updateTexture(textureMapper);
-    if (texture)
-        textureMapper->drawTexture(*texture.get(), targetRect, matrix, opacity);
+    if (texture) {
+#if USE(OPENGL_ES_2) && GST_CHECK_VERSION(1, 1, 2)
+        if (m_orientation == GST_VIDEO_GL_TEXTURE_ORIENTATION_X_NORMAL_Y_FLIP) {
+            TransformationMatrix matrix(modelViewMatrix);
+            matrix.rotate3d(180, 0, 0);
+            matrix.translateRight(0, targetRect.height());
+            textureMapper->drawTexture(*texture.get(), targetRect, matrix, opacity);
+        }
+        else {
+            textureMapper->drawTexture(*texture.get(), targetRect, modelViewMatrix, opacity);
+        }
+#else
+        textureMapper->drawTexture(*texture.get(), targetRect, modelViewMatrix, opacity);
+#endif
+    }
 }
 #endif
 
@@ -457,6 +573,7 @@ GstElement* MediaPlayerPrivateGStreamerBase::createVideoSink()
     m_webkitVideoSink = webkitVideoSinkNew();
 
     m_repaintHandler = g_signal_connect(m_webkitVideoSink.get(), "repaint-requested", G_CALLBACK(mediaPlayerPrivateRepaintCallback), this);
+    m_drainHandler = g_signal_connect(m_webkitVideoSink.get(), "drain", G_CALLBACK(mediaPlayerPrivateDrainCallback), this);
 
     m_fpsSink = gst_element_factory_make("fpsdisplaysink", "sink");
     if (m_fpsSink) {
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.h b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.h
index dfcab59..d916248 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.h
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.h
@@ -41,6 +41,12 @@ typedef struct _GstMessage GstMessage;
 typedef struct _GstStreamVolume GstStreamVolume;
 typedef struct _WebKitVideoSink WebKitVideoSink;
 
+typedef struct _GstMiniObject GstMiniObject;
+
+typedef struct _GstEGLImageMemoryPool GstEGLImageMemoryPool;
+typedef struct _GstEGLImageMemory GstEGLImageMemory;
+typedef struct _EGLDetails EGLDetails;
+
 namespace WebCore {
 
 class GraphicsContext;
@@ -76,6 +82,8 @@ public:
     void setSize(const IntSize&);
     void sizeChanged();
 
+    void triggerDrain();
+
     void triggerRepaint(GstBuffer*);
     void paint(GraphicsContext*, const IntRect&);
 
@@ -116,6 +124,7 @@ protected:
     GRefPtr<GstElement> m_fpsSink;
     MediaPlayer::ReadyState m_readyState;
     MediaPlayer::NetworkState m_networkState;
+    bool m_isEndReached;
     IntSize m_size;
     GMutex* m_bufferMutex;
     GstBuffer* m_buffer;
@@ -124,9 +133,11 @@ protected:
     unsigned long m_repaintHandler;
     unsigned long m_volumeSignalHandler;
     unsigned long m_muteSignalHandler;
+    unsigned long m_drainHandler;
     mutable IntSize m_videoSize;
 #if USE(ACCELERATED_COMPOSITING) && USE(TEXTURE_MAPPER_GL) && !USE(COORDINATED_GRAPHICS)
     PassRefPtr<BitmapTexture> updateTexture(TextureMapper*);
+    guint m_orientation;
 #endif
 };
 }
diff --git a/Source/WebCore/platform/graphics/gstreamer/VideoSinkGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/VideoSinkGStreamer.cpp
index 17d0aef..96ab7e0 100644
--- a/Source/WebCore/platform/graphics/gstreamer/VideoSinkGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/VideoSinkGStreamer.cpp
@@ -38,16 +38,42 @@
 #include <wtf/OwnPtr.h>
 #include <wtf/gobject/GMutexLocker.h>
 
+#if USE(EGL)
+#define WL_EGL_PLATFORM
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#endif
+
+#if USE(OPENGL_ES_2)
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+#if GST_CHECK_VERSION(1, 3, 0)
+#include <gst/gl/egl/gsteglimagememory.h>
+#include <gst/gl/gstglutils.h>
+
+#endif
+#endif
+
 using namespace WebCore;
 
 // CAIRO_FORMAT_RGB24 used to render the video buffers is little/big endian dependant.
 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
+#if USE(OPENGL_ES_2) && GST_CHECK_VERSION(1, 3, 0)
+#define GST_CAPS_FORMAT "{ RGBA }"
+#else
 #define GST_CAPS_FORMAT "{ BGRx, BGRA }"
+#endif
 #else
 #define GST_CAPS_FORMAT "{ xRGB, ARGB }"
 #endif
+
 #if GST_CHECK_VERSION(1, 1, 0)
-#define GST_FEATURED_CAPS GST_VIDEO_CAPS_MAKE_WITH_FEATURES(GST_CAPS_FEATURE_META_GST_VIDEO_GL_TEXTURE_UPLOAD_META, GST_CAPS_FORMAT) ";"
+#define GST_FEATURED_CAPS_GL GST_VIDEO_CAPS_MAKE_WITH_FEATURES(GST_CAPS_FEATURE_META_GST_VIDEO_GL_TEXTURE_UPLOAD_META, GST_CAPS_FORMAT) ";"
+#if GST_CHECK_VERSION(1, 3, 0)
+#define GST_FEATURED_CAPS GST_FEATURED_CAPS_GL GST_VIDEO_CAPS_MAKE_WITH_FEATURES(GST_CAPS_FEATURE_MEMORY_EGL_IMAGE, GST_CAPS_FORMAT) ";"
+#else
+#define GST_FEATURED_CAPS GST_FEATURED_CAPS_GL
+#endif
 #else
 #define GST_FEATURED_CAPS
 #endif
@@ -62,6 +88,7 @@ GST_DEBUG_CATEGORY_STATIC(webkitVideoSinkDebug);
 
 enum {
     REPAINT_REQUESTED,
+    DRAIN,
     LAST_SIGNAL
 };
 
@@ -91,11 +118,44 @@ struct _WebKitVideoSinkPrivate {
     //
     // Protected by the buffer mutex
     bool unlocked;
+
+#if USE(OPENGL_ES_2) && GST_CHECK_VERSION(1, 3, 0)
+    GstBufferPool *pool;
+    GstBuffer *last_buffer;
+
+    GstGLDisplay *display;
+    GstGLContext *context;
+    GstGLContext *other_context;
+
+    GCond* allocateCondition;
+    GMutex* allocateMutex;
+    GstBuffer* allocateBuffer;
+#endif
 };
 
 #define webkit_video_sink_parent_class parent_class
 G_DEFINE_TYPE_WITH_CODE(WebKitVideoSink, webkit_video_sink, GST_TYPE_VIDEO_SINK, GST_DEBUG_CATEGORY_INIT(webkitVideoSinkDebug, "webkitsink", 0, "webkit video sink"));
 
+static gboolean _ensure_gl_setup(WebKitVideoSink* gl_sink)
+{
+    GError* error = NULL;
+
+    if (!gst_gl_ensure_display(gl_sink, &gl_sink->priv->display))
+        return FALSE;
+
+    if (!gl_sink->priv->context) {
+        gl_sink->priv->context = gst_gl_context_new(gl_sink->priv->display);
+
+        if (!gst_gl_context_create(gl_sink->priv->context, gl_sink->priv->other_context, &error)) {
+            GST_ELEMENT_ERROR(gl_sink, RESOURCE, NOT_FOUND, ("%s", error->message), (NULL));
+            gst_object_unref(gl_sink->priv->context);
+            gl_sink->priv->context = NULL;
+            return FALSE;
+        }
+    }
+
+    return TRUE;
+}
 
 static void webkit_video_sink_init(WebKitVideoSink* sink)
 {
@@ -111,6 +171,18 @@ static void webkit_video_sink_init(WebKitVideoSink* sink)
 #endif
 
     gst_video_info_init(&sink->priv->info);
+
+#if USE(OPENGL_ES_2) && GST_CHECK_VERSION(1, 3, 0)
+    g_object_set(GST_BASE_SINK(sink), "enable-last-sample", FALSE, NULL);
+    sink->priv->pool = NULL;
+    sink->priv->last_buffer = NULL;
+
+    sink->priv->allocateCondition = g_new0(GCond, 1);
+    g_cond_init(sink->priv->allocateCondition);
+    sink->priv->allocateMutex = g_new0(GMutex, 1);
+    g_mutex_init(sink->priv->allocateMutex);
+    sink->priv->allocateBuffer = NULL;
+#endif
 }
 
 static gboolean webkitVideoSinkTimeoutCallback(gpointer data)
@@ -129,6 +201,9 @@ static gboolean webkitVideoSinkTimeoutCallback(gpointer data)
     }
 
     g_signal_emit(sink, webkitVideoSinkSignals[REPAINT_REQUESTED], 0, buffer);
+#if USE(OPENGL_ES_2) && GST_CHECK_VERSION(1, 3, 0)
+    gst_buffer_replace (&priv->last_buffer, buffer);
+#endif
     gst_buffer_unref(buffer);
     g_cond_signal(priv->dataCondition);
 
@@ -249,6 +324,18 @@ static void webkitVideoSinkDispose(GObject* object)
         priv->bufferMutex = 0;
     }
 
+#if USE(OPENGL_ES_2) && GST_CHECK_VERSION(1, 3, 0)
+    if (sink->priv->allocateCondition) {
+        g_cond_clear(priv->allocateCondition);
+        g_free(priv->allocateCondition);
+    }
+
+    if (sink->priv->allocateMutex) {
+        g_mutex_clear(priv->allocateMutex);
+        g_free(priv->allocateMutex);
+    }
+#endif
+
     G_OBJECT_CLASS(parent_class)->dispose(object);
 }
 
@@ -307,7 +394,8 @@ static gboolean webkitVideoSinkUnlockStop(GstBaseSink* baseSink)
 
 static gboolean webkitVideoSinkStop(GstBaseSink* baseSink)
 {
-    WebKitVideoSinkPrivate* priv = WEBKIT_VIDEO_SINK(baseSink)->priv;
+    WebKitVideoSink* sink = reinterpret_cast_ptr<WebKitVideoSink*>(baseSink);
+    WebKitVideoSinkPrivate* priv = sink->priv;
 
     unlockBufferMutex(priv);
 
@@ -316,6 +404,16 @@ static gboolean webkitVideoSinkStop(GstBaseSink* baseSink)
         priv->currentCaps = 0;
     }
 
+#if USE(OPENGL_ES_2) && GST_CHECK_VERSION(1, 3, 0)
+    GST_OBJECT_LOCK (sink);
+    if (priv->last_buffer)
+        gst_buffer_replace (&priv->last_buffer, NULL);
+    if (priv->pool)
+        gst_object_unref (priv->pool);
+    priv->pool = NULL;
+    GST_OBJECT_UNLOCK (sink);
+#endif
+
     return TRUE;
 }
 
@@ -347,23 +445,129 @@ static gboolean webkitVideoSinkSetCaps(GstBaseSink* baseSink, GstCaps* caps)
 
 static gboolean webkitVideoSinkProposeAllocation(GstBaseSink* baseSink, GstQuery* query)
 {
-    GstCaps* caps;
-    gst_query_parse_allocation(query, &caps, 0);
+    WebKitVideoSink* sink = WEBKIT_VIDEO_SINK(baseSink);
+    GstCaps* caps = NULL;
+    gboolean need_pool;
+
+    gst_query_parse_allocation(query, &caps, &need_pool);
     if (!caps)
         return FALSE;
 
-    WebKitVideoSink* sink = WEBKIT_VIDEO_SINK(baseSink);
     if (!gst_video_info_from_caps(&sink->priv->info, caps))
         return FALSE;
 
+#if USE(OPENGL_ES_2) && GST_CHECK_VERSION(1, 3, 0)
+    // Code adapted from gst-plugins-bad's glimagesink.
+
+    GstBufferPool* pool;
+    GstStructure* config;
+    guint size;
+    GstAllocator* allocator = 0;
+    GstAllocationParams params;
+
+    if (!_ensure_gl_setup(sink))
+        return FALSE;
+
+    if ((pool = sink->priv->pool))
+        gst_object_ref(pool);
+
+    if (pool) {
+        GstCaps* pcaps;
+
+        // We had a pool, check its caps.
+        GST_DEBUG_OBJECT (sink, "check existing pool caps");
+        config = gst_buffer_pool_get_config(pool);
+        gst_buffer_pool_config_get_params(config, &pcaps, &size, 0, 0);
+
+        if (!gst_caps_is_equal(caps, pcaps)) {
+            GST_DEBUG_OBJECT(sink, "pool has different caps");
+            // Different caps, we can't use this pool.
+            gst_object_unref(pool);
+            pool = 0;
+        }
+        gst_structure_free(config);
+    }
+
+    if (need_pool && !pool) {
+        GstVideoInfo info;
+
+        if (!gst_video_info_from_caps(&info, caps)) {
+            GST_DEBUG_OBJECT(sink, "invalid caps specified");
+            return FALSE;
+        }
+
+        GST_DEBUG_OBJECT(sink, "create new pool");
+        pool = gst_gl_buffer_pool_new(sink->priv->context);
+
+        // The normal size of a frame.
+        size = info.size;
+
+        config = gst_buffer_pool_get_config(pool);
+        gst_buffer_pool_config_set_params(config, caps, size, 0, 0);
+        if (!gst_buffer_pool_set_config(pool, config)) {
+            GST_DEBUG_OBJECT(sink, "failed setting config");
+            return FALSE;
+        }
+    }
+
+    // We need at least 2 buffer because we hold on to the last one.
+    if (pool) {
+        gst_query_add_allocation_pool(query, pool, size, 2, 0);
+        gst_object_unref(pool);
+    }
+
+    gst_query_add_allocation_meta(query, GST_VIDEO_META_API_TYPE, 0);
+
+    gst_allocation_params_init(&params);
+    allocator = gst_allocator_find(GST_EGL_IMAGE_MEMORY_TYPE);
+    gst_query_add_allocation_param(query, allocator, &params);
+    gst_object_unref(allocator);
+#else
     gst_query_add_allocation_meta(query, GST_VIDEO_META_API_TYPE, 0);
     gst_query_add_allocation_meta(query, GST_VIDEO_CROP_META_API_TYPE, 0);
-#if GST_CHECK_VERSION(1, 1, 0)
     gst_query_add_allocation_meta(query, GST_VIDEO_GL_TEXTURE_UPLOAD_META_API_TYPE, 0);
 #endif
     return TRUE;
 }
 
+static gboolean webkitVideoSinkQuery(GstBaseSink* baseSink, GstQuery* query)
+{
+    WebKitVideoSink* sink = WEBKIT_VIDEO_SINK(baseSink);
+    WebKitVideoSinkPrivate* priv = sink->priv;
+
+    switch (GST_QUERY_TYPE(query)) {
+    case GST_QUERY_DRAIN:
+    {
+#if USE(OPENGL_ES_2) && GST_CHECK_VERSION(1, 3, 0)
+        GST_OBJECT_LOCK (sink);
+        if (priv->last_buffer)
+            gst_buffer_replace (&priv->last_buffer, NULL);
+        g_signal_emit(sink, webkitVideoSinkSignals[DRAIN], 0);
+        GST_OBJECT_UNLOCK (sink);
+#endif
+        return TRUE;
+    }
+    case GST_QUERY_CONTEXT:
+    {
+        return gst_gl_handle_context_query(GST_ELEMENT(sink), query, &priv->display);
+      break;
+    }
+    default:
+        return GST_CALL_PARENT_WITH_DEFAULT(GST_BASE_SINK_CLASS, query, (baseSink, query), TRUE);
+      break;
+    }
+}
+
+#if GST_CHECK_VERSION(1, 3, 0)
+static void
+webkitVideoSinkSetContext(GstElement* element, GstContext* context)
+{
+    WebKitVideoSink* sink =  WEBKIT_VIDEO_SINK(element);
+
+    gst_gl_handle_set_context(element, context, &sink->priv->display);
+}
+#endif
+
 static void webkit_video_sink_class_init(WebKitVideoSinkClass* klass)
 {
     GObjectClass* gobjectClass = G_OBJECT_CLASS(klass);
@@ -386,6 +590,11 @@ static void webkit_video_sink_class_init(WebKitVideoSinkClass* klass)
     baseSinkClass->start = webkitVideoSinkStart;
     baseSinkClass->set_caps = webkitVideoSinkSetCaps;
     baseSinkClass->propose_allocation = webkitVideoSinkProposeAllocation;
+    baseSinkClass->query = webkitVideoSinkQuery;
+
+#if GST_CHECK_VERSION(1, 3, 0)
+    elementClass->set_context = webkitVideoSinkSetContext;
+#endif
 
     g_object_class_install_property(gobjectClass, PROP_CAPS,
         g_param_spec_boxed("current-caps", "Current-Caps", "Current caps", GST_TYPE_CAPS, G_PARAM_READABLE));
@@ -400,6 +609,17 @@ static void webkit_video_sink_class_init(WebKitVideoSinkClass* klass)
             G_TYPE_NONE, // Return type
             1, // Only one parameter
             GST_TYPE_BUFFER);
+
+    webkitVideoSinkSignals[DRAIN] = g_signal_new("drain",
+            G_TYPE_FROM_CLASS(klass),
+            static_cast<GSignalFlags>(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION),
+            0, // Class offset
+            0, // Accumulator
+            0, // Accumulator data
+            g_cclosure_marshal_generic,
+            G_TYPE_NONE, // Return type
+            0 // No parameters
+            );
 }
 
 
diff --git a/Source/WebCore/platform/graphics/gstreamer/WebKitWebSourceGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/WebKitWebSourceGStreamer.cpp
index d5b46c4..5890c5e 100644
--- a/Source/WebCore/platform/graphics/gstreamer/WebKitWebSourceGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/WebKitWebSourceGStreamer.cpp
@@ -820,7 +820,7 @@ bool webKitSrcPassedCORSAccessCheck(WebKitWebSrc* src)
 }
 
 StreamingClient::StreamingClient(WebKitWebSrc* src)
-    : m_src(adoptGRef(static_cast<GstElement*>(gst_object_ref(src))))
+    : m_src(static_cast<GstElement*>(gst_object_ref(src)))
 {
 }
 
diff --git a/Source/autotools/FindDependencies.m4 b/Source/autotools/FindDependencies.m4
index 76d74ba..f767a28 100644
--- a/Source/autotools/FindDependencies.m4
+++ b/Source/autotools/FindDependencies.m4
@@ -445,6 +445,7 @@ if test "$enable_video" = "yes" || test "$enable_web_audio" = "yes"; then
         gstreamer-fft-1.0,
         gstreamer-base-1.0,
         gstreamer-pbutils-1.0,
+        gstreamer-gl-1.0,
         gstreamer-video-1.0])
     AC_SUBST([GSTREAMER_CFLAGS])
     AC_SUBST([GSTREAMER_LIBS])
diff --git a/Source/autotools/SetupLibtool.m4 b/Source/autotools/SetupLibtool.m4
index 05545ca..161ff7f 100644
--- a/Source/autotools/SetupLibtool.m4
+++ b/Source/autotools/SetupLibtool.m4
@@ -6,11 +6,7 @@ AC_SUBST([LIBJAVASCRIPTCOREGTK_VERSION])
 AC_SUBST([LIBWEBKIT2GTK_VERSION])
 
 if test -z "$AR_FLAGS"; then
-    if "${AR:-ar}" -V | grep -q 'GNU ar'; then
-        AR_FLAGS="cruT"
-    else
-        AR_FLAGS="cru"
-    fi
+    AR_FLAGS="cru"
 fi
 AC_SUBST([AR_FLAGS])
 
